// GrammarTranslatorSem.cs                                              HDO, 2006-08-28
// -------------
// Semantic evaluator for table-driven top-down parsing.
// Generated by Coco-2 (PGT).
//=====================================|========================================

using System;
using System.Text;

using Lex = GrammarTranslatorLex;
using Syn = GrammarTranslatorSyn;

public class GrammarTranslatorSem {


  public const String MODULENAME = "GrammarTranslatorSem";

  public static void GrammarTranslatorSemMethod(Utils.ModuleAction action, out String moduleName) {
  //-----------------------------------|----------------------------------------
    moduleName = MODULENAME;
    switch (action) {
      case Utils.ModuleAction.getModuleName:
        return;
      case Utils.ModuleAction.initModule:
        break;
      case Utils.ModuleAction.resetModule:
        break;
      case Utils.ModuleAction.cleanupModule:
        return;
    } // switch
  } // GrammarTranslatorSemMethod


  // *** start of global SYN and SEM declarations from ATG ***
  
  private static System.Collections.Generic.List<Rule> rules = new System.Collections.Generic.List<Rule>();
  	private static SymbolNameGenerator symbolNameGenerator = new SymbolNameGenerator();

  // *** end of global SYN and SEM declarations from ATG ***

  

  private static void NT_GrammarTranslator() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Rule();
          break;
        case 2: // SEM
          Console.WriteLine("Rules:");
          			foreach (Rule r in rules) {
          				Console.WriteLine(r);
          			}
          		
          break;
      } // switch
    } // for
  } // NT_GrammarTranslator

  private static void NT_Rule() {
    Rule rule = new Rule();
    			String nonterminal = "";
    		
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          Lex.GETnonterminalAttr(out nonterminal);
          break;
        case 2: // SEM
          rule.NonTerminal = nonterminal;
          		
          break;
        case 3:
          NT_Alternatives(ref rule);
          break;
        case 4: // SEM
          rules.Add(rule);
          		
          break;
      } // switch
    } // for
  } // NT_Rule

  private static void NT_Alternatives(ref Rule rule) {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Alternative(ref rule);
          break;
        case 2:
          NT_Alternative(ref rule);
          break;
      } // switch
    } // for
  } // NT_Alternatives

  private static void NT_Alternative(ref Rule rule) {
    String nonterminal = "";
    			String terminal = "";
    			
    			Alternative alternative = new Alternative();
    			
    			Rule groupRule = null;
    			Rule optionalRule = null;
    			Rule repetitionRule = null;
    		
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          rule.AddAlternative(alternative);
          		
          break;
        case 2:
          Lex.GETnonterminalAttr(out nonterminal);
          break;
        case 3: // SEM
          alternative.AddSymbol(new Symbol(nonterminal, Symbol.Kind.NONTERMINAL));
          				
          break;
        case 4:
          Lex.GETterminalAttr(out terminal);
          break;
        case 5: // SEM
          alternative.AddSymbol(new Symbol(terminal, Symbol.Kind.TERMINAL));
          				
          break;
        case 6: // SEM
          groupRule = new Rule();
          					groupRule.NonTerminal = symbolNameGenerator.Generate();
          					rules.Add(groupRule);
          					alternative.AddSymbol(new Symbol(groupRule.NonTerminal, Symbol.Kind.NONTERMINAL));
          				
          break;
        case 7:
          NT_Grouping(ref groupRule);
          break;
        case 8: // SEM
          optionalRule = new Rule();
          					optionalRule.NonTerminal = symbolNameGenerator.Generate();
          					
          					// add empty alternative
          					optionalRule.AddAlternative(new Alternative());
          					
          					rules.Add(optionalRule);
          					alternative.AddSymbol(new Symbol(optionalRule.NonTerminal, Symbol.Kind.NONTERMINAL));
          				
          break;
        case 9:
          NT_Optional(ref optionalRule);
          break;
        case 10: // SEM
          repetitionRule = new Rule();
          					repetitionRule.NonTerminal = symbolNameGenerator.Generate();
          					
          					rules.Add(repetitionRule);
          					alternative.AddSymbol(new Symbol(repetitionRule.NonTerminal, Symbol.Kind.NONTERMINAL));
          				
          break;
        case 11:
          NT_Repetition(ref repetitionRule);
          break;
        case 12: // SEM
          // add recursion to every alternative
          					foreach (Alternative a in repetitionRule.GetAlternatives()) {
          						a.AddSymbol(new Symbol(repetitionRule.NonTerminal, Symbol.Kind.NONTERMINAL));
          					}
          					
          					// add empty alternative
          					repetitionRule.AddAlternative(new Alternative());
          				
          break;
      } // switch
    } // for
  } // NT_Alternative

  private static void NT_Grouping(ref Rule rule) {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Alternatives(ref rule);
          break;
      } // switch
    } // for
  } // NT_Grouping

  private static void NT_Optional(ref Rule rule) {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Alternatives(ref rule);
          break;
      } // switch
    } // for
  } // NT_Optional

  private static void NT_Repetition(ref Rule rule) {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Alternatives(ref rule);
          break;
      } // switch
    } // for
  } // NT_Repetition


  public delegate void PragmaMethod();
  public static PragmaMethod[] pragmaMethods = {
      // none
    };


  public static void StartSem() {
  //-----------------------------------|----------------------------------------
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_GrammarTranslator();
          break;
      } // switch
    } // for
  } // StartSem

    
} // GrammarTranslatorSem

// End of GrammarTranslatorSem.cs
//=====================================|========================================